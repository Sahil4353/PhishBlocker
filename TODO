boom—fresh snapshot, up to the minute.

# What we’ve accomplished (current state)

* **FastAPI app** with factory + lifespan; routers by concern:

  * `pages` (HTML): `/`, **PRG** `POST /scan → 303 /scan/{id}/view?ok=1`, `/history`, `/scan/{id}/view`
  * `scans` (JSON & export): `/scan/{id}`, `/export/csv`
  * `debug`: `/health`, `/_debug/scan_count`, `/_debug/cwd`
* **Templates/UI**

  * **Scan Detail (HTML)** with label, confidence, reasons, body preview
  * **History** with pagination + CSV export form (label & date filters)
  * **Result** now links to detail / JSON / history / new scan
* **Classifier**: heuristics in `app/services/heuristics.py` (precompiled regex, precedence, confidence scaling)
* **Central logging & request IDs**

  * `app/core/logging.py` + `ENABLE_LOGGING` / `LOG_LEVEL`
  * `app/core/middleware.py` adds `X-Request-ID` on every response
* **DB layer**: SQLite with WAL, safe session dependency, auto table create on startup
* **CSV export (secure)**

  * Filters: `label`, `date_from`, `date_to`
  * Excel-injection guard for cells starting with `= + - @`
* **PRG polish**

  * `GET /scan` → 303 to `/` (no more 405 noise)
  * URL building fixed with `include_query_params`
* **Tests (in main)**

  * **Heuristics unit tests**
  * **Routes/PRG integration**: POST redirect, GET /scan redirect, JSON detail, request-id header
  * **Isolated test env**: `pytest.ini` + `tests/conftest.py` (temp SQLite, startup runs)

**In PR (tests/full-suite):**

* CSV export tests (headers, filters, Excel guard for subject/sender/**body\_preview**)
* History/pages smoke (pagination text, debug endpoints)
* Scans JSON roundtrip + 404
* Error-path test (forced DB commit failure → 500 + request-id)

---

# Roadmap to final project (updated)

## M1 — MVP polish (Local) ✅ nearly done

* [x] Detail page + history links
* [x] CSV export + filters (+ guard)
* [x] PRG for `/scan`
* [x] Basic tests (heuristics + PRG)
* [ ] Merge **full-suite** PR (CSV/history/error-path tests)

## M2 — Gmail ingestion (near real-time)

1. Gmail API + OAuth (capture refresh token)
2. Watch + Pub/Sub push → `POST /webhooks/gmail`
3. Fetch messages → dedupe → scan → persist

## M3 — Real ML baseline

TF-IDF + LR/SVM, calibrated; saved `.joblib`; show model version on `/health`; fall back to heuristics.

## M4 — Auth, roles, feedback loop

Session/OAuth login, gated history/admin, label corrections stored for retrain.

## M5 — Prod & CI/CD

Docker + Postgres, deploy (Render/Fly/AWS), GitHub Actions (lint/test/build/deploy), logs/metrics/alerts.

## M6 — Safety, privacy & retention

Data minimization + purge job; CSP/HSTS; CSRF; rate limiting; secrets management.

---

# Risks & quick mitigations

* Gmail watch drift/expiry → store and refresh `historyId`; resync window on error
* Webhook idempotency → dedupe by Gmail `messageId`/`historyId`
* Dataset realism → mix modern ham & adversarial phish (punycode, zero-width, shorteners)
* Explainability → reasons from top n-grams/URLs, not only char grams
* CSV safety → guarded (done)

---

# Acceptance checklist (final “done”)

* [ ] Live site (auth, HTTPS, domain)
* [ ] Gmail push → webhook → fetch → scan → history
* [ ] Paste-to-scan uses **model** + reasons
* [ ] Detail page + filters + CSV export
* [ ] Feedback loop exportable
* [ ] Unit/integration tests passing in CI
* [ ] Alembic runs on deploy
* [ ] Logs + basic metrics + alerts
* [ ] Retention job + secrets managed

---

# What we do next (pick one)

**Track A: Quick UI polish (30–60 min)**

* Colored label chips in History/Detail
* Add sender/subject filters to History
* A few focused tests for those behaviors

**Track B: Gmail OAuth (M2.1, 2–3 hrs to first token)**

* Google Cloud project + OAuth client
* Minimal `/auth/google` flow to capture refresh token
* Scaffold `/webhooks/gmail` with verification

Tell me your pick, and I’ll guide step-by-step like before.
